1) В какой версии Java появились параметризованные типы?  
**Ответ.** К наиболее важным новшествам версии языка J2SE 5 можно отнести появление параметризации (generic) классов и методов, позволяющей использовать гибкую и в то же время достаточно строгую типизацию, что особенно важно при работе с коллекциями  
**Источник.** JAVA_Methods_Programming_v2.march2015 c.68  


2) Приведите 2 примера кода: первый без параметризованного типа; второй - этот же код с параметризованным типом, иллюстрирующий преимущество данного варианта.  
**Ответ.** Код, использующий универсальные шаблоны, имеет много преимуществ перед неуниверсальным кодом: Более строгие проверки типов во время компиляции. Компилятор Java применяет строгую проверку типов к универсальному коду и выдает ошибки, если код нарушает безопасность типов. Исправлять ошибки времени компиляции проще, чем исправлять ошибки времени выполнения, которые бывает сложно найти. Следующий фрагмент кода без универсальных шаблонов требует приведения:  
```java
List list = new ArrayList();
list.add("hello");
String s = (String) list.get(0);
```
При использовании дженериков код не требует приведения:  
```java
List<String> list = new ArrayList<String>();
list.add("hello");
String s = list.get(0);   // no cast
```  
**Источник.** https://docs.oracle.com/javase/tutorial/java/generics/why.html  


3) Какие типы данных запрещены в качестве параметров классов?  
**Ответ.** В качестве параметров классов запрещено применять примитивные типы.  
**Источник.** http://crypto.pp.ua/2010/06/parametrizovannye-klassy-java/  


4) Дан код:
```java
class Gen <T1, T2 extends Number, T3 extends Object> { … }
```  
Какие типы можно использовать в качестве аргументов T1, T2, T3?  
**Ответ.**  
a) T1 и T3 - любые типы, кроме базовых.  
b) T2 - Объекты класса ``Number`` и его наследники.  


5) Дан код:
```java
class Gen1 <T> { … }
class Gen2 <T extends Object> { … }
class Runner {
	private final static Gen1<Object> g11 = new Gen1<>();
	private final static Gen1 g12 = new Gen1();
	private final static Gen2<Object> g21 = new Gen2<>();
	private final static Gen2 g22 = new Gen2();
	...
}
```
В чем различие объявления классов Gen1 и Gen2?  
Есть ли преимущество в объявлении g11 по сравнению с g12? Обоснуйте Ответ.  
Есть ли преимущество в объявлении g21 по сравнению с  g12? Обоснуйте Ответ.  
В каком случае используется второй способ (g12, g22)?  
**Ответ.** 
a) Различий нет, явное или не явное наследование класса ``Object``, никак не влияет.  
b) В ``private final static Gen1 g12 = new Gen1();`` не выполняется никакой проверки типов, в то время как ``private final static Gen1<Object> g11 = new Gen1<>();`` точно говорит компилятору, что g11 может содержать объект любого типа. Существуют правила образования подтипов в обобщенном программировании. К примеру, Gen1 <String> не стал бы являться подтипом для Gen1 <Object>, однако при этом он является подтипом для сырого типа Gen1. Следовательно, мы теряем в безопасности типов в случае использования raw type (строка 2), но сохраняем ее при использовании параметризированного типа (строка 1).  
c) Данная ситуация аналогична рассмотренной в вопросе "b)"  
d) Для совместимости с кодом написаным до версии Java 1.5.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html  
Блох Дж. – Java. Эффективное программирование, 2 издание. Статья 23.  


6) Дан код:
```java
class SubInfo extends Info { … }
class Gen1 <T> { … }
class Gen2 <T extends Info> { … }
```
Является ли декларация Gen1<Info> подклассом Gen2<Info>?  
Является ли декларация Gen1<SubInfo> подклассом Gen1<Info>?  
Является ли декларация Gen2<SubInfo> подклассом Gen2<Info>?  
**Ответ.**  
a) Нет, потому что класс Gen2 не является базовым классом для Gen1.  
b, c) Не является.  


7) Почему нельзя вызвать конструктор generic-типа?  
**Ответ.** невозможно выполнить явный вызов конструктора generic-типа:  
```java
class FailedOne <T> {
 private T value = new T();
}
```  
так как компилятор не знает, какой конструктор может быть вызван и какой объем памяти должен быть выделен при создании объекта.  
**Источник.** Java. Методы программирования. И.Н. Блинов, В.С. Романчик c.73  


8) Почему нельзя создать generic-поле?  
**Ответ.** Статическое поле класса - это переменная уровня класса, совместно используемая всеми нестатическими объектами класса. Следовательно, статические поля параметров типа не допускаются.  
```java
public class MobileDevice<T> {
    private static T os;

    // ...
}
```  
Если бы статические поля параметров типа были разрешены, то следующий код был бы запутан:  
```java
MobileDevice<Smartphone> phone = new MobileDevice<>();
MobileDevice<Pager> pager = new MobileDevice<>();
MobileDevice<TabletPC> pc = new MobileDevice<>();
```  
Поскольку статическое поле os используется телефоном, пейджером и компьютером, каков фактический тип операционной системы? Это не может быть одновременно смартфон, пейджер и планшетный компьютер. Следовательно, вы не можете создавать статические поля параметров типа.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/generics/restrictions.html  


9) Почему статический метод не может иметь generic-параметр?  
**Ответ.** Если метод нестатический, а класс - параметризованный, то параметр типа наследуется из описания класса:
```java  
public class A<T> {
    pubic void doSth(T t) { // метод принимает аргумент типа T
        System.out.println(t.getClass().getName());
    }
}

new A<String>().doSth("abc");   // выведет java.lang.String
new A<String>().doSth(123);     // не скомпилируется
```  
Если метод статический, то унаследовать параметр типа от класса он не может. Это вызвано тем, что параметр типа привязывается к конкретному объекту при его создании, а статический метод не привязан к конкретному объекту, он привязан к классу в целом. В случае статического метода параметр типа нужно указывать непосредственно перед объявлением метода:
```java
public class A {
    public static <T> void doSth(T t) {
        System.out.println(t.getClass().getName());
    }
}

A.doSth("abc");         // выведет java.lang.String
A.doSth(123);           // выведет java.lang.Integer
```  
В этом случае тип T определяется в момент вызова статического метода по типу передаваемого аргумента.


10) Предложите более эффективную запись данного кода:  
```java
<T> void make1(Gen <T extends Object> gen) { … }
<T, S extends T> void make2(Info<T> info1, Info<S> info2) { … }
```  
**Ответ.**  
```java
<T> void make1(Gen <T> gen) { … }
<T> void make2(Info<T> info1, Info<? extends T> info2) { … }
```  


11) Дан код:  
```java
class Info { 
	public <T1> Info() { … }
	public <T2> Info(T2 t2) { … }
	public <T1> void make1(T1 t1) { … }
	public <T3> void make2() { … }
}
```  
Создайте какой-либо экземпляр класса Info  
конструктором без аргументов,  
конструктором с аргументом.  
Синтаксически правильно вызовите методы make1() и make2().  
**Ответ.** 
a) ``Info info = new Info();``  
b) ``Info infoString = new Info("Hello generic");``  
c) ``info.make1("");``  
d) ``info.make2();``  


12) Поясните данный код:  
``static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll)``  
**Ответ.** Метод max() используется для возврата максимального элемента данной коллекции в соответствии с естественным упорядочением ее элементов. Все элементы в коллекции должны реализовывать интерфейс Comparable. Кроме того, все элементы в коллекции должны быть взаимно сопоставимы (т.е. ``e1.compareTo(e2)`` не должно создавать исключение ClassCastException для любых элементов e1 и e2 в коллекции).  
Параметры: Этот метод принимает коллекцию coll любого подтипа T как параметр, максимальный элемент которого должен быть определен.  
Возвращаемое значение: этот метод возвращает максимальный элемент данной коллекции в соответствии с естественным порядком ее элементов.  
**Источник.** https://docs.oracle.com/javase/tutorial/extra/generics/convert.html