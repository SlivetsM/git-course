1) Какие уровни доступа есть у класса на верхнем уровне, т.е. у внешнего класса?  
**Ответ.** public, package-private (уровень доступа по умолчанию).  
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html  


2) Что является членами класса?  
**Ответ.** Поля, методы, вложенные классы, вложенные интерфейсы. В том числе все унаследованные члены от суперкласса и интерфейсов.  
**Источник.** https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.2  

 
3) Что еще можно определить в классе кроме членов?  
**Ответ.** Конструкторы, статические инициализаторы и инициализаторы экземпляров.  
**Источник.** https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.2  

 
4) Какие уровни доступа есть у членов класса?  
**Ответ.** Поля класса, как и методы, объявляются также со спецификаторами доступа public, private, protected или по умолчанию без спецификатора.  
**Источник.** И.Н.Блинов Java Методы программирования – с. 55  


5) Какие модификаторы необходимы для определения константы: 
a) класса,  
b) экземпляра класса?  
**Ответ.** Константа класса определяется при помощи спецификаторов static final.  
Константа экземпляра определяется при помощи спецификатора final.  
**Источник.** И.Н.Блинов, В.С.Романчук Java 2 проктическое руководство – с. 46


6) Обратный вопрос. Допустим, у некоторого класса есть 4 следующих поля:  
```java
class SomeClass {
	private int a;
	private final int b;
private static int c;
private static final int D;
...
}
```  
Как можно назвать данные поля в зависимости от комбинации модификаторов static и final?  
**Ответ.** 
`private int a` - поле экземпляра класса, `private final int b` - константа экземпляра класса, `private static int c` – поле класса, `private static final int D` - константа класса.  
 
 
7) Может ли класс не иметь ни одного конструктора? Почему?  
**Ответ.** Не может. Дело в том, что если конструктор класса не определен явно, то в Java для класса создается конструктор по умолчанию. Конструктор по умолчанию инициализирует все переменные экземпляра устанавливаемыми по умолчанию значениями. Но как только в классе будет определен собственный конструктор, конструктор по умолчанию больше не используется.  
**Источник.** https://www.examclouds.com/ru/java/java-core-russian/konstruktori 


8) Перечислите отличия конструктора от метода.  
**Ответ.** Определение конструктора и метода  
Конструктор похож на метод экземпляра в Java, за исключением возвращаемого типа. Конструкторы - это специальные типы методов в Java, используемые для инициализации объектов своего класса. Он имеет то же имя, что и класс, в котором он находится. Методы, с другой стороны, относятся к набору кода, который может быть вызван в любой точке программы через имя метода для выполнения некоторой задачи и возврата результата..  
Цель конструктора и метод  
Целью конструктора является создание экземпляра класса. Это достигается созданием объекта в памяти и возвращением ссылки на него. Это специальный тип метода, используемый для инициализации объекта сразу после его создания. С другой стороны, цель метода состоит в том, чтобы сгруппировать блок операторов для выполнения операций над уже существующими объектами..  
Имя  
Конструкторы обозначаются тем же именем, что и имя класса, и они не имеют возвращаемого типа. Ключевое слово ``new`` используется для создания объекта класса и вызова конструктора для инициализации созданного объекта. Методы, напротив, именуются не так, как имя класса, и они должны быть объявлены до того, как он что-то возвратит, хотя методы могут быть недействительными.  
Наследование конструктора и метода  
Конструкторы не наследуются подклассами, так как они не являются членами класса. Однако конструктор суперкласса (родительского класса) может быть вызван из подкласса. Методы, с другой стороны, наследуются подклассом, чтобы обеспечить возможность повторного использования кода.  
Функция конструктора и метода  
Конструкторы не могут быть вызваны напрямую. Фактически, конструкторы вызываются неявно, когда для создания объектов используется ключевое слово new. Методы, с другой стороны, являются статическими по своей природе, что означает, что их можно вызывать напрямую, не создавая экземпляр этого класса. Фактически, методы начинают работать в существующем потоке.  
**Источник.** https://ru.sawakinome.com/articles/technology/difference-between-constructor-and-method-3.html  
 
 
9) Как и в каком месте можно вызвать из одного конструктора другой конструктор этого же класса?  
**Ответ.** С помощью ключевого слова ``this(values)``, где values - список аргументов вызываемого конструктора этого же класса. Причем данное ключевое слово должно всегда идти первым оператором в теле конструктора.  
 **Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html  
 
 
10) Как и в каком месте можно вызвать конструктор суперкласса?  
**Ответ.** Если класс наследует свойства другого класса, подкласс автоматически получает конструктор по умолчанию суперкласса. Но если вы хотите вызвать параметризованный конструктор суперкласса, вам нужно использовать ключевое слово ``super``. ``super(values)``  
**Источник.** https://hr-vector.com/java/nasledovanie  
 
 
11) Что делает компилятор, если в конструкторе нет вызова другого конструктора или конструктора суперкласса?  
**Ответ.** Каждый конструктор при отсутствии явных вызовов других конструкторов неявно вызывает с помощью ``super()`` конструктор без аргументов родительского класса, при этом у вас всегда остается возможность явно вызвать любой другой конструктор с помощью либо ``this()``, либо ``super()``.  
**Источник.** https://javarush.ru/groups/posts/1187-raznica-mezhdu-kljuchevihmi-slovami-this-i-super-v-java  


12) Можно ли одновременно использовать конструкции this() и super() в одном и том же конструкторе? Обоснуйте ответ.  
**Ответ.** Внутри конструктора ``this`` и ``super`` должны стоять выше всех других выражений, в самом начале, иначе компилятор выдаст сообщение об ошибке. Из чего следует, что в одном конструкторе не может быть одновременно и ``this()``, и ``super()``.  
**Источник.** https://javarush.ru/groups/posts/1187-raznica-mezhdu-kljuchevihmi-slovami-this-i-super-v-java  


13) Может ли быть приватный уровень доступа у конструктора? Если да, то для каких целей он необходим?  
**Ответ.** Частные конструкторы предотвращают явное создание экземпляра класса вызывающими объектами. Есть несколько распространенных случаев, когда может быть полезен частный конструктор:  
a) классы, содержащие только статические служебные методы  
b) классы, содержащие только константы  
c) типобезопасные перечисления  
d) синглтоны  
Эти примеры делятся на две категории.  
Строительство объекта категорически запрещено. Никакие объекты не могут быть созданы ни вызывающим, ни собственным классом. Это подходит только для классов, которые предлагают вызывающему только статические члены. В этих случаях отсутствие конструктора доступа говорит вызывающему: «Для этого класса нет вариантов использования, когда вам нужно построить объект. Вы можете использовать только статические элементы. Я не позволяю вам даже пытаться построить объект. этого класса ".  
**Источник.** http://www.javapractices.com/topic/TopicAction.do?Id=40  


14) Какие модификаторы может иметь конструктор?  
**Ответ.** В конструкторе допускается применение модификаторов доступа, можно задать один из модификаторов: ``public``, ``protected``, ``private`` или без модификатора.  
**Источник.** https://javarush.ru/groups/posts/1391-konstruktorih-klassov-java-jdk-15  


15) Конструктор принадлежит классу или экземпляру класса?  
**Ответ.** Конструктор принадлежит классу, но вызывается в контексте экземпляра класса.  
**Источник.** https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.8.3  


16) Можно ли наследовать конструктор? Если да, то приведите примеры.  
**Ответ.** в Java конструкторы не являются членами, поэтому они не наследуются подклассом, но конструктор суперкласса может быть вызван из подкласса.  
**Источник.** https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.2  

17) Какой тип возвращаемого конструктором значения?  
**Ответ.** Конструкторы же не имеют возвращаемого типа, они не могут возвращать даже тип ``void``.  
**Источник.** http://www.javable.com/javaworld/10_00/01/  


18) Дан класс.
```java
class Null {
	//фрагмент 1
	Null Null() {
		return null;
	}
	//фрагмент 2
	Null() {
		return null;
	}
}
```
В каком фрагменте ошибка компиляции?  
Удалите этот фрагмент полностью.  
Прокомментируйте оставшийся фрагмент и продемонстрируйте функционал класса.  
**Ответ.** Ошибка во втором фрагменте. Конструктор не может вернуть ``null``.  
```java
 class Null {
    public static void main(String[] args) {
        Null test = new Null(); // создаем экземпляр класса Null, с помощью конструктора по умолчанию
        test.Null();// вызывается метод Null на объект test и возвращается значение null
        System.out.println(test); // output: null
    }
    //фрагмент 1
    Null Null() {
        return null;
    }
}
```

19) Если метод имеет то же имя, как и класс, то каким образом транслятор определяет где метод, а где конструктор (см. пример выше)?
**Ответ.** Конструктор в отличие от метода ничего не возвращает.  
**Источник.** https://ru.sawakinome.com/articles/technology/difference-between-constructor-and-method-3.html  


20) Дан класс.
```java
class Name {
	String name;
	Name() {
		this(makeRandomName());
	}
	Name(String name) {
		super();
		this.name = name;
	}
	String makeRandomName() {
		int k = (int) (Math.random() * 3);
		String name = new String[] {"Alpha", "Beta", "Gamma"}[k];
		return name;
	}
	public String toString() {
		return name;
	}
	public static void main(String[] args) {
		System.out.println(new Name());
	}
}
```
Объясните причину ошибки компиляции. 
Предложите минимум 2 способа исправления ошибки, использовать метод makeRandomName() обязательно.  
**Ответ.** Проблема заключается в том что метод ``makeRandomName()`` является метдом экземпляра класса и не будет доступен до тех пор, пока ``super`` не будет вызван из конструктора, что приведет к инициализации класса. Вы пытаетесь вызвать ``makeRandomName()`` до того, как вызов super инициализирует класс, что приведет к ошибке компиляции.  
```java
//Вариант 1:
class Name {
    String name;
    Name() {
        this(makeRandomName());
    }
    Name(String name) {
        super();
        this.name = name;
    }
    static String makeRandomName() {
        int k = (int) (Math.random() * 3);
        String name = new String[] {"Alpha", "Beta", "Gamma"}[k];
        return name;
    }
    public String toString() {
        return name;
    }
    public static void main(String[] args) {
        System.out.println(new Name());
    }
}
//Вариант 2:
class Name {
    String name;
    Name() {
        this.name = makeRandomName();
    }
    Name(String name) {
        super();
        this.name = name;
    }
    String makeRandomName() {
        int k = (int) (Math.random() * 3);
        String name = new String[] {"Alpha", "Beta", "Gamma"}[k];
        return name;
    }
    public String toString() {
        return name;
    }
    public static void main(String[] args) {
        System.out.println(new Name());
    }
}
```  


21) Дан класс.  
```java
class Int {
	int i;
	void inc(Int param) {
		//param = new Int();
		param.i++;
	}
	public static void main(String[] args) {
		Int obj = new Int();
		obj.inc(obj);
		System.out.println(obj.i);
	}
}
```
Изменится ли результат, если убрать комментарий? Объясните, почему?  
**Ответ.** Да, изменится. В Java имеется вызов только по значению, а значит, в метод передается копия ссылки на экземпляр класса ``Int``. Ссылка указывает на объект, который находится в куче и изменяется его состояние (поле экземпляра класса стало равным 1), а после выхода из метода объект не меняет своего состояния, тем самым, значение поля ``i`` остается равным 1. При добавлении строки ``param = new Int();`` заносится ссылка на созданный объект, но так как вызов происходит по значению, то это всего лишь копия ссылки. Таким образом, после выхода из метода переменная ``obj`` продолжит ссылаться на экземпляр класса ``Int``, где ``i = 0``.  


22) Что входит в сигнатуру метода?  
**Ответ.** Имя метода, число и типы параметров образуют сигнатуру (signature) метода.  
**Источник.** Ильдар Хабибуллин «Самоучитель Java» с. 87  


23) Что значит ключевое слово native?  
**Ответ.** Приложение на языке Java может вызывать методы, написанные на языке С++(либо на другом языке). Такие методы объявляются с ключевым словом native, которое сообщает компилятору, что метод реализован в другом месте. Например: ``public native int loadCripto(int num)``. Методы, помеченные ``native``, можно переопределять обычными методами в подклассах.  
**Источник.** И.Н.Блинов Java Методы программирования – с. 64  


24) Перечислите, какой код в классе можно выполнить до создания объекта.  
**Ответ.** При создании объекта класса логические блоки вызываются последовательно, в порядке размещения, вместе с инициализацией полей как простая последовательность операторов, и только после выполнения последнего блока будет вызван конструктор класса.  
**Источник.** И.Н.Блинов, В.С.Романчук Java 2 проктическое руководство – с. 50  

 
25) В чем различие между объектом и экземпляром класса?  
**Ответ.** Объект: объекты реального мира имеют две основные характеристики: состояние и поведение. У человека есть состояние (имя, возраст) и поведение (бег, сон). Автомобиль имеет состояние (текущая скорость, текущая передача) и поведение (включение тормоза, переключение передач). Программные объекты концептуально похожи на объекты реального мира: они также состоят из состояния и связанного поведения. Объект сохраняет свое состояние в полях и раскрывает свое поведение с помощью методов.  
Экземпляр - это уникальная копия класса, представляющая объект. Когда создается новый экземпляр класса, JVM выделяет пространство памяти для этого экземпляра класса.  
**Источник.** https://alfredjava.wordpress.com/2008/07/08/class-vs-object-vs-instance/  


26) Назовите три этапа создания экземпляра класса.  
**Ответ.**  
a) Декларация. Декларирование переменной типа класса с уникальным именем.  
b) Инстанциация. Создание нового объекта с использованием ключевого слова ``new``.  
c) Инициализация. Вызов конструкторов, который идёт после ключевого слова ``new``.  
**Источник.** https://proselyte.net/tutorials/java-core/classes-and-objects/  
 
 
27) Охарактеризуйте отношение композиции между классами? Как оно реализуется?  
**Ответ.** Композиция является одним из методов проектирования, который реализовывает отношение типа has-a в классах. Мы можем использовать наследование в Java или композицию для повторного использования кода.  
Композиция в Java достигается за счет использования переменных экземпляра, который ссылается на другие объекты.  
Небольшой пример в теории: Person has a (имеет) Job.
```java 
public class Job {
    private String role;
    private long salary;
    private int id;
         
    public String getRole() {
        return role;
    }
    public void setRole(String role) {
        this.role = role;
    }
    public long getSalary() {
        return salary;
    }
    public void setSalary(long salary) {
        this.salary = salary;
    }
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    } 
}
 
public class Person {
 
    //используем отношение has-a
    private Job job;
    
    public Person(){
        this.job=new Job();
        job.setSalary(1000L);
    }
    public long getSalary() {
        return job.getSalary();
    } 
}

public class TestPerson {
 
    public static void main(String[] args) {
        Person person = new Person();
        long salary = person.getSalary();
    }
 
}
```
Обратите внимание, что тестовая программа TestPerson не зависит от каких-либо изменений в объекте Job. Если вам нужно реализовать взаимодействие двух классов и вы хотите повторно использовать код, то лучшим выходом будет использование композиции вместо наследования.
Преимущества использования композиции в том, что мы можем управлять видимостью другого объекта для клиентских классов и повторно использовать только то, что нам нужно. Кроме того, если есть какие-либо изменения в другой реализации класса, например, если  метод ``getSalary()`` начнет возвращать строку, то мы должны изменить класс Person, а не классы клиента.
Композиция в Java позволяет создавать back-end класс, когда это необходимо. Например, мы можем изменить ``getSalary()`` метод класса ``Person`` для инициализации объекта ``Job``.  
**Источник.** https://javadevblog.com/chto-takoe-kompozitsiya-primer-kompozitsii-v-java.html  

 
28) Для чего предназначен метод toString()? В каких случаях он вызывается?  
**Ответ.** Возвращает строковое представление объекта. Каждый раз, когда мы пытаемся вывести ссылку на ``Object``, вызывается метод ``toString()``. 
Если мы не определили в классе метод ``toString()``, то будет вызван метод ``toString()`` класса ``Object``.  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html  


29) Как реализован метод toString() в классе Object?  
**Ответ.** 
```java
public String toString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }
```  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html  


30) Для чего предназначен метод ``equals()``? В каких случаях он вызывается?  
**Ответ.** Метод equals реализует отношение эквивалентности для ненулевых ссылок на объекты. Вызывается при необходимости сравнения содержимого объектов.  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html  


31) Как реализован метод equals() в классе Object?  
```java
**Ответ.** public boolean equals(Object obj) {
        return (this == obj);
    }
```  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html  


32) В чем различие между методом equals() и операции ==? В каких случаях применение метода equals() и операции == эквивалентно?  
**Ответ.** В Java сравнение объектов производится с помощью метода ``equals()`` класса ``Object``. Этот метод сравнивает содержимое объектов и выводит значение типа ``boolean``. Значение ``true`` - если содержимое эквивалентно, и ``false`` — если нет. Операция == не рекомендуется для сравнения объектов в Java. Дело в том, что при сравнении объектов, операция == вернет true лишь в одном случае — когда ссылки указывают на один и тот же объект. В данном случае не учитывается содержимое переменных класса. При создании пользовательского класса, принято переопределять метод ``equals()`` таким образом, что бы учитывались переменные объекта. Применение метода ``equals()`` и операции == эквивалентно, если мы сравниваем элементы перечисления или мы сравниваем ссылки, которые указывают на один и тот же объект. Все элементы перечисления существуют в единственном экземпляре, это контролируется на уровне виртуальной машины.   
**Источник.** https://www.examclouds.com/ru/java/java-core-russian/method-equals  


33) Что такое garbage collection?  
**Ответ.** Сборщик м усора (garbage collection) автоматически управляет запросами на выделение динамической памяти приложения.
Сборщик мусора выполняет автоматическое управление динамической памятью с помощью следующих операций:  
a) Выделяет и возвращает память операционной системе.  
b) Выдает эту память приложению, когда оно запрашивает ее.  
c) Определяет, какие части этой памяти все еще используются приложением.  
d) Освобождает неиспользуемую память для повторного использования приложением.  
**Источник.** https://docs.oracle.com/javase/9/gctuning/introduction-garbage-collection-tuning.htm#JSGCT-GUID-8A443184-7E07-4B71-9777-4F12947C8184  


34) Перечислите случаи, когда JVM отдает управление на garbage collector.  
**Ответ.**  
a) Если переменная ссылочного типа, которая ссылается на объект, установлена в положение "0", объект подлежит утилизации, в том случае, если на него нет других ссылок.  
b) Если переменная ссылочного типа, которая ссылается на объект, создана для ссылки на другой объект, объект подлежит утилизации, в том случае, если на него нет других ссылок.  
c) Объекты, созданные локально в методе, подлежат утилизации, когда метод завершает работу, если только они не экспортируются из этого метода (т.е, возвращаются или генерируются как исключение).  
d) Объекты, которые ссылаются друг на друга, могут подлежать утилизации, если ни один из них не доступен живому потоку.  
**Источник.** https://javarush.ru/groups/posts/917-sborka-musora  


35) Как сделать так, чтобы JVM сразу перешла в режим сборки мусора?  
**Ответ.** Для запроса запуска сборщика мусора используют один из методов: 
``System.gc()``;  
``Runtime.getRuntime().gc()``  
Форсировать сборку мусора нельзя.  
**Источник.** https://javarush.ru/groups/posts/917-sborka-musora  


36) Гарантирует ли garbage collector, что приложение в любом случае не будет иметь проблемы с недостатком памяти?
Обоснуйте ответ.  
**Ответ.** JVM обычно запускает сборщик мусора при низком уровне свободной памяти. Но работа сборщика мусора не гарантирует, что всегда будет оставаться достаточно свободной памяти.
Если памяти недостаточно даже после восстановления, JVM генерирует исключение OutOfMemoryError. Обратите внимание, что перед генерированием исключения JVM обязательно запускает сборщик мусора как минимум 1 раз.  
**Источник.** И. Блинов. Java. Методы программирования. с. 118.  


37) Для чего предназначен метод finalize()? Какой недостаток у метода?  
**Ответ.** Общий контракт ``finalize()`` заключается в том, что он вызывается, если и когда виртуальная машина Java TM определила, что больше нет никаких средств, с помощью которых к этому объекту можно получить доступ для любого потока, который еще не умер, кроме как в результате предпринятого действия. путем завершения некоторого другого объекта или класса, который готов к завершению. Метод ``finalize()`` может предпринимать любые действия, в том числе делать этот объект снова доступным для других потоков; однако обычная цель ``finalize()`` - выполнить действия по очистке до того, как объект будет безвозвратно удален.   Спецификация языка Java не только не даёт поручительства, что методы ``finalize()`` будут вызваны быстро, она не даёт гарантии, что они вообще будут вызваны. Вполне возможно и даже очень вероятно, что программа завершится, так и не вызвав для некоторых объектов, ставших недоступными, метода ``finalize()``. Как следствие, вы никогда не должны полагаться на метод ``finalize()`` для обновления критического хранимого (persistent) состояния. Например, ставить освобождение хранимой блокировки разделяемого ресурса, такого как база данных, в зависимость от метода ``finalize()`` — верный способ привести всю вашу распределённую систему к сокрушительному краху. Если в ходе утилизации возникает необработанное исключение, оно игнорируется, а вызов метода ``finalize()`` прекращается [JLS, 12.6]. Необработанное исключение может оставить объект в испорченном состоянии. И если другой поток попытается воспользоваться таким испорченным объектом, результат может быть непредсказуем. Обычно необработанное исключение завершает поток и выдаёт распечатку стека, однако в методе ``finalize()`` этого не происходит, он даже не даёт предупреждений. Так же очень сильно замедляется создание и уничтожение объектов.  
**Источник.** Джошуа Блох «Effective Java: Programming Language Guide» с. 54-55  
https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html  


38) Для чего предназначены оболочечные классы? Как они называются на инглише?  
**Ответ.** Классы-оболочки(wrapper) примитивных типов - предназначены для действий, типичных при работе с классами, — создания объектов, преобразования типов объектов, получения численных значений объектов в разных формах и передачи объектов в методы по ссылке.  
**Источник.** Ильдар Хабибуллин «Самоучитель Java» с.133  


39) В чем преимущество примитивных типов перед соответствующими оболочечными классами?  
**Ответ.** Арифметические действия удобнее и быстрее производить с примитивными типами, а не с объектами классов, которые требуют много ресурсов от компьютера.  
**Источник.** Ильдар Хабибуллин «Самоучитель Java» с.133  


40) Что такое autoboxing и unboxing?  
**Ответ.** Autoboxing - это автоматическое преобразование, которое компилятор Java выполняет между примитивными типами и соответствующими им классами-оболочками объектов. Например, преобразование ``int`` в ``Integer``, ``double`` в ``Double`` и т.д. Если преобразование идет другим путем, это называется распаковкой.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html  


41) Дан код:
```java
Integer a = 3, b =7;
Long c = a + b;
```
Перечислите все операции, где задействованы autoboxing и unboxing.
**Ответ.** Операции где задействован autoboxing: ``Integer a = 3, b = 7``; ``Long c = a + b//при присвоении результата вычисления``.
Операция где задействован unboxing: ``a + b``;  


42) Дан корректный раннер-класс. Будет ли ошибка компиляции, если удалить модификатор static из сигнатуры метода main()? Обоснуйте ответ.
Что произойдет, если отправить на выполнение измененный класс?  
**Ответ.** Ошибки не произойдет, метод ``main()`` можно объявить по правилам любого другого метода. Но только в двух случаях,он будет являться точкой входа в программу.  
```java
public static void main(String[] args)
public static void main(String ... args)
```
При запуске измененного класса, программа не запуститься, т.к. точка входа не определена. Error: Main method is not static in class Runner, please define the main method as:
``public static void main(String[] args)``.
 
**Источник.** https://docs.oracle.com/javase/tutorial/getStarted/application/  


43) Дан класс.
```java
class Runner {
	public static void main(String[] args) {
        	System.out.println("Hello, world!");
	}
}
```
Запрещается изменять синий код, т.е. метод main().
Добавить код в класс Runner, так чтобы в результате запуска этого класса из под JVM в консоли был следующий результат:
I am java.
Hello, world!  
**Ответ.** 
```java
class Runner {
    static{
        System.out.println("I am Java");
    };
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
```  


44) В чем смысл конструкции this? Перечислите случаи, когда используется конструкция this. В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими возможностями. Если можно, то каким образом?  
**Ответ.** ``this`` - это ссылка на текущий объект.  
Конструкция this используется:  
a) Для доступа к полям, перекрытым одноимёнными аргументами или локальными переменными метода или конструктора. Можно избежать использования ``this``, используя разные имена для полей класса и  локальных данных.  
b) Внутри конструктора для вызова другого конструктора этого же класса. Это называется явным вызовом конструктора. В этом случае можно избежать использования ``this()`` только путём дублирования кода.  
c) Для возврата ссылки на текущий объект. Заменить нельзя.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html  


45) Можно ли присвоить null ссылочной переменной this?  
**Ответ.** . Нет, компилятор этого не позволит, ``this`` объявлена как ``final``. Будет ошибка компиляции.  
**Источник.** http://www.java67.com/2013/06/difference-between-this-and-super-keyword-java.html  


46) Перечислите случаи, когда используется статический блок?  
В каких случаях можно обойтись без него. Если можно, то каким образом?  
**Ответ.** Статический блок применяется, если инициализацию поля невозможно записывать одним выражением или же, нужна обработка исключений. Без статического блока можно обойтись если статическое поле можно проинициализировать при его объявлении.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html  


  
47) Перечислите случаи, когда используется логический блок?  
В каких случаях можно обойтись без него. Если можно, то каким образом?  
**Ответ.** Логический блок применяется в тех же случаях как и статический блик когда инициализацию поля невозможно сделать одним выражением или нужна обработка исключений. Без логического блока можно обойтись если поле экземпляра класса можно проинициализировать при объявлении или в конструкторе класса.  **Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html  


48) Дан код. 
```java
public class BusinessTrip {
  …
  public String bynToStr(int value) {
    return (value / 100) + "." + (value / 10 % 10) + (value % 10);
  }
}
```
Есть ли в нем семантическая ошибка?
Если да, то обоснуйте. 
**Ответ.** Да. Метод ``bynToStr(int value)`` должен быть статическим.


49) К каким данным можно обратиться в статическом методе?  
**Ответ.** В статическом методе можно обратиться:  
●	к статическим членам класса;  
●	к переменным, которые объявленные в этом методе;  
●	к аргументам метода.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html  


50) Почему нельзя объявить статическое поле внутри метода?  
Ответ. Статическое поле принадлежит классу, а поля метода - самому методу вне зависимости от того, статичен он или нет. И если статическое поле создается один раз еще до создания хотя бы одного экземпляра класса и существует на протяжении всего времени выполнения программы, использующей данный класс, то поля метода - только во время исполнения метода и никогда до или после.  
Источник. https://javarush.ru/groups/posts/800-10-zametok-o-modifikatore-static-v-java  


51) Дан код. 
```java
public class Utility {
  private Utility() {
  }
  public String bynToStr(int value) {
    return (value / 100) + "." + (value / 10 % 10) + (value % 10);
  }
}
```
Есть ли в нем семантическая ошибка? Если да, то предложите альтернативные варианты.  
**Ответ.** Если это полный код класа, то из-за модификатора `private` у конструктора экземпляр данного класса невозможно создать. Решение заменить модификатор доступа на любой другой позволяющий создать экземпляр класса или же дописать класс со `static` методом организующем `singletone`.  


52) Допустим, необходимо, чтобы метод возвращал два значения одного примитивного типа. Предложите способы и подтвердите примерами.  
**Ответ.** Вернуть в методе больше одного значения можно только косвенно через массив, коллекцию или другой объект-обёртку содержащий эти два элемента.  
```java
class Something {
    // через массив
    int[] doSomething1() {
		int value1 = ...;
		int value2 = ...;
		return new int[]{value1, value2};
	}
	// через объект класса обёртки
	Pair doSomething2() {
		int value1 = ...;
		int value2 = ...;
		return new Pair(value1, value2);
	}
}
// Класс обёртка
class Pair {
	int value1;
	int value2;
	Pair(int value1, int value2) {
		this.value1 = value1;
		this.value2 = value2;
	}	
}
```  


53) Допустим, необходимо, чтобы метод возвращал два значения разных примитивных типов. Предложите способы и подтвердите примерами.  
**Ответ.** Необходимо использовать класс обертку с необходимыми полями.  
```java
class Something {
	Pair doSomething() {
		String value1 = ...;
		int value2 = ...;
		return new Pair(value1, value2);
	}
}
class Pair {
	String value1;
	int value2;
	Pair(String value1, int value2) {
		this.value1 = value1;
		this.value2 = value2;
	}	
}
```


54) Опишите 2 способа создания иммутабельных объектов.  
Подсказка. Способ 1 - класс материала в classes2. 
Какой альтернативный?  
Подсказка - ключевое слово final для полей не использовать.  
Создайте иммутабельный класс для вещества по альтернативному способу.  
**Ответ.**  
a) - объявить поля объекта с модификатором ``final``.  
b) - просто исключить возможность изменять состояние объекта (не объявлять сеттеры и другие методы для изменения внутреннего состояния), а модифицирующие методы должны возвращать новые экземпляры класса.  
```java
public class Material {
	private String name;
	private double density;
 
	public Material() {
    		this(0.0, null);
	}
	public Material(double density, String name) {
    	this.density = density;
    	this.name = name;
	}
	public String getName() {
    		return name;
	}
	public double getDensity() {
    		return density;
	}
}
```  
**Источник.** https://docs.oracle.com/javase/tutorial/essential/concurrency/imstrat.html  


55) Даны 2 класса.
```java
final class Material {
        private final String name;
        private final double density;
        ...
}
class Runner {
        private static void printMaterial(final Material material) {
                System.out.println(material);
        }
        public static void main(String[] args) {
                Material steel = new Material("steel",7850);
                printMaterial(steel);
        }
}
```
В методе printMaterial() по ссылке material создается новый объект или имеется доступ к объекту new Material("steel",7850)?
Какой пример можно использовать для обоснования ответа?
**Ответ.** В методе ``printMaterial()`` новый объект не создается, а создается копия ``final`` ссылки на тот же объект. Проверить равенство можем используя метод ``equals()`` класса ``Object``, который сравнит ссылки наших объектов (можно было написать и ==). Использовать метод ``hashCode()`` для обоснования ответа мы не можем, т. к если хеш-коды равны, то входные объекты не всегда равны.
Пример:
```java
final class Material {
        private final String name;
        private final double density;
        ...
}
class Runner {
  private static Material printMaterial(final Material material) {
       System.out.println(material);
       return material;
  }
  public static void main(String[] args) {
       Material steel = new Material("steel",7850);
       System.out.println(printMaterial(steel).equals(steel));
  }
}
```  
**Источник:** https://habr.com/post/168195/  


56) Класс для комплексного числа содержит два поля:
```java
class Complex {
	private double re;
	private double im;
	…
}
```
Реализуйте в данном классе методы: plus() для операции + и add() для +=.  
Приведите пример использования каждого метода.  
Реализуйте эти же методы при условии, что класс Complex является иммутабельным.  
**Ответ.**  
```java
class Complex {
	private double re;
	private double im;
	public Complex(double re, double im) {
		this.re = re;
		this.im = im;
	}
	public Complex plus(Complex b) {
		return new Complex(re + b.re, im + b.im);
	}
	public void add(Complex b) {
		this.re += b.re;
		this.im += b.im;
	}
}

class ImmutableComplex {
	private double re;
	private double im;
	public ImmutableComplex(double re, double im) {
		this.re = re;
		this.im = im;
	}
	public ImmutableComplex plus(ImmutableComplex b) {
		return new ImmutableComplex(re + b.re, im + b.im);
	}
	public ImmutableComplex add(ImmutableComplex b) {
		return plus(b);
	}
}
```  


57) Eclipse в стандартной конфигурации генерирует начало метода equals() следующим образом:
```java
public boolean equals(Object obj) {
if (this == obj)
return true;
if (obj == null)
return false;
```  
С чем связаны данные проверки, которые кажутся лишними?  
**Ответ.**
a) ``if (this == obj)`` Проверка равенства ссылок. При их равенстве, значительно сокращается время работы метода. Это правило рефлексивности.
b) ``if (obj == null)`` Для любой ненулевой ссылки на значение x, выражение ``x.equals(null)`` должно возвращать ``false``. Это условие предотвращает возникновение NullPointerException.
Эти проверки вынесены в начало метода, т.к. часто срабатывают в реальных приложениях. Это ускоряет работу, позволяя методу ``equals()`` возвратить результат раньше, чем будут выполнены более медленные проверки (например, ``instanceof``).  
Источник. https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html#equals(java.lang.Object)  


Бонусное задание 1 (необязательное)
В задаче classes3 имеются два константных поля в классе покупки.
Им сразу присваиваются значения по умолчанию.
Например.
```java
public class Purchase {
  public final static String PRODUCT_NAME = "milk";
  public final static int PRICE = 120;
  ...
}
```
Измените реализацию так, чтобы константы инициализировались значениями из текстового файла, находящемся в том же пакете, что и класс покупки. Имя файла - константа в классе покупки.
Если будет сбой с файлом или в нем будут недопустимые значения, то присвойте константам PRODUCT_NAME и PRICE значения по умолчанию.
Для этого же примера начало класса должно быть таким:  
```java
public class Purchase {
	private static final String PRODUCT_NAME;
	private static final int PRICE;
	public static final String FILE_NAME = "src/by/gsu/epamlab/constants.txt";
	private static final String DEFAULT_PRODUCT_NAME = "milk";
	private static final int DEFAULT_PRICE = 120;
}
  ```
**Ответ.**  
```java
public class Purchase1 {
	private static final String PRODUCT_NAME;
	private static final int PRICE;
	private static final String FILE_NAME = "src/by/gsu/epamlab/constants.txt";
	private static final String DEFAULT_PRODUCT_NAME = "milk";
	private static final int DEFAULT_PRICE = 120;

	static {
		String name;
		int price;
		try (Scanner sc = new Scanner(new FileReader(FILE_NAME))) {
			name = sc.next();
			price = sc.nextInt();
		} catch (Exception e) {
			name = DEFAULT_PRODUCT_NAME;
			price = DEFAULT_PRICE;
		}
		PRODUCT_NAME = name;
		PRICE = price;
	}	
…
}
```

