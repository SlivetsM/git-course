1) Что такое JVM?  
**Ответ.** Java Virtual Machine (виртуальная машина Java) – основная часть исполняющей системы Java, так называемой Java Runtime Environment (JRE).  
Виртуальная машина Java интерпретирует байт-код Java, предварительно созданный из исходного кода Java-программы компилятором Java (Javac). JVM может также использоваться для выполнения программ, написанных на других языках программирования.
**Источник.** https://docs.oracle.com/javase/tutorial/getStarted/intro/definition.html  
https://docs.oracle.com/javase/7/docs/technotes/guides/index.html#jre-jdk  

 
2) Что такое JDK?  
**Ответ.** JDK — Java Development Kit — комплект разработчика приложений на языке Java, включающий в себя JRE, компилятор, стандартные библиотеки классов, примеры, документацию, различные утилиты.  
Другими словами JDK — это программное обеспечение необходимое разработчику для написания java-приложений.
приложений и документацию разработчика.
В состав JDK не входит интегрированная среда разработки на Java, поэтому разработчик, использующий только JDK, вынужден использовать внешний текстовый редактор и компилировать свои программы, используя утилиты командной строки.  
**Источник.**  https://www.techopedia.com/definition/5594/java-development-kit-jdk  

 
3) Что такое JRE?  
**Ответ.** Java Runtime Environment — среда выполнения Java — минимальная реализация виртуальной машины, необходимая для исполнения Java-приложений, без компилятора и других средств разработки. Состоит из виртуальной машины (Java Virtual Machine), библиотеки Java-классов и дополнительных компонентов для запуска приложений и апплетов, написанных на Java.  
**Источник.**https://www.quora.com/What-is-difference-between-JDK-JRE-and-JVM  

 
4) Даны корректные исходные файлы: Hello.java и hello.cpp. Каждый из них преобразуется в исполняемый код, который запускается на выполнение. Назовем данный процесс жизненным циклом приложения. В чем отличие жизненных циклов этих приложений?  
**Ответ.** Исходная Java-программа Hello.java транслируется в байт-код компилятором javac.exe. Оттранслированная в байт-код программа имеет расширение class. Для запуска программы нужно вызвать интерпретатор java.exe, указав в параметрах вызова, какую программу ему следует выполнять. Кроме того, ему нужно указать, какие библиотеки нужно использовать при выполнении программы. Библиотеки размещены в файлах с расширением jar.  
Для того чтобы выполнить исходную программу hello.cpp, требуется перевести ее на язык, понятный процессору — в машинные коды. Этот процесс состоит из нескольких этапов.  
Сначала программа передается препроцессору, который выполняет директивы, содержащиеся в ее тексте.
Получившийся полный текст программы поступает на вход компилятора, который строит объектный модуль.
Компоновщик формирует исполняемый модуль программы, подключая к объектному модулю другие объектные модули, в том числе содержащие функции библиотек, обращение к которым содержится в любой программе. Если программа состоит из нескольких исходных файлов, они компилируются по отдельности и объединяются на этапе компоновки. Исполняемый модуль имеет расширение ехе. Но на другом сочетании устройства и ОС нужно провести повторную компиляцию исходных файлов, так как машинный код с другого устройства при их различии не исполнится.
Отличия: 
a.	Приложения java запускаются в виртуальной среде JVM, а C++ в операционной системе.
b.	Сlass-файлы Java в отличие от приложений С++ не содержат инструкций для конкретного процессора и могут запускаться на разных платформах.
c.	Программы java не могут напрямую работать с памятью в отличие от С++
d.	Все стандартные библиотеки уже включены в JRE их не нужно добавлять в исходные файлы на Java  
**Источник.**https://docs.oracle.com/javase/tutorial/getStarted/intro/definition.html
http://www.javable.com/tutorials/fesunov/lesson1/  

 
5) Перечислите группы примитивных типов данных и состав каждой группы.  
**Ответ.** Существует восемь примитивных типов данных в Java и три группы:
Целые типы (integral types) – ``byte``, ``short``, ``int``, ``long`` 
Вещественные типы (floating-point types) – ``float``, ``double``
Логический тип – ``boolean``
Символьный тип – ``char``;  
**Источник.** http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html
Н.Блинов, В.С. Романчик. Методы программирования. Глава 2, стр. 32.  
 

6) Какой размер данного булевского типа?  
**Ответ.** Этот тип данных представляет собой один бит информации, но его «размер» не определен. Зависит от реализации JVM.  
**Источник.** https://metanit.com/java/tutorial/2.12.php

 
7) Какой размер данного символьного типа?
**Ответ.** Размер данного символьного типа - 2 байта(16 бит).
**Источник.** https://metanit.com/java/tutorial/2.12.php


8) Какими литералами можно инициализировать символьную переменную?
**Ответ.** ‘A’ - символьный литерал, заданные напрямую любым отображаемым символом Unicode;
‘\uxxxx’ - символ Unicode, где xxxx цифровой код символа Unicode в шестнадцатеричной форме;
Управляющие символы
\n’ - конец строки;
‘\t’ - табуляция;
‘\b’ - забой;
‘\f’ - конец страницы;
‘\r’ - возврат каретки;
‘\”’ - двойная кавычка;
‘\’’ - одинарная кавычка;
‘\\’ - обратный слэш;
1046 - код символа Unicode в десятичном исчислении (от 0 до 65535);
0x0950 - код символа Unicode в шестнадцатеричном формате.
**Источник.** Ильдар Хабибуллин «Самоучитель Java» стр. 34-35 
https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html

 
9) Какие есть виды переменных?
**Ответ.**  Язык программирования Java определяет следующие типы переменных:
a. Переменные экземпляра (нестатические поля). С технической точки зрения объекты сохраняют свои отдельные состояния в «нестатических полях», то есть поля, объявленные без ключевого слова ``static``. Нестатические поля также известны как переменные экземпляра, поскольку их значения уникальны для каждого экземпляра класса (для каждого объекта).
b. Переменные класса (статические поля). Переменной класса является любое поле, которое объявляется с помощью ``static`` модификатора; это говорит компилятору, что существует только одна копия этой переменной, независимо от того, сколько раз экземпляр класса был создан. Поле, определяющее количество передач для определенного вида велосипеда, можно отметить, ``static`` поскольку концептуально одинаковое количество передач будет применяться ко всем экземплярам. Код: 
```java 
static int numGears = 6;
```
создавал бы такое статическое поле. Кроме того, ключевое слово ``final`` можно добавить, чтобы указать, что количество передач никогда не изменится.
c. Локальные переменные. Подобно тому, как объект сохраняет свое состояние в полях, метод часто сохраняет свое временное состояние в локальных переменны. Синтаксис объявления локальной переменной аналогичен объявлению поля например:
```java
int count = 0
```  
Не существует специального ключевого слова, определяющего переменную как локальную; это определение целиком исходит из того места, где объявлена переменная, которая находится между открывающей и закрывающейся фигурными скобками метода. Таким образом, локальные переменные видны только тем методам, в которых они объявлены; они недоступны из остальной части класса.
d. Параметры (аргументы метода). В подписи для ``main`` метода 
```java
public static void main(String[] args)
```
args переменная является параметром этого метода. Важно помнить, что параметры всегда классифицируются как «переменные», а не «поля».  
**Источник.** https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html  

 
10) В какой области памяти хранятся локальные переменные?  
**Ответ.**  Локальные переменные хранятся в стеке (Java Virtual Machine stack). Если локальная переменная является объектом, то ссылка на объект хранится в стеке, а значение - в куче (heap).  
Стек-  это область хранения данных находящейся в общей оперативной памяти (RAM), но процессор предоставляет прямой доступ к ней с использованием указателя стека. Указатель стека перемещается вниз для выделения памяти или вверх для ее освобождения.  
Это чрезвычайно быстрый и эффективный способ размещения данных, по скорости уступающий только регистрам. Во время обработки программы компилятор Java должен знать жизненный цикл данных, размещаемых в стеке.  
Это ограничение уменьшает гибкость ваших программ, поэтому, хотя некоторые данные Java хранятся в стеке (особенно ссылки на объекты), сами объекты Java не помещаются в стек.
**Источник.** https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html.  
”Промышленное программирование” Блинов,Романчик.  

 
11) В какой области памяти хранятся аргументы метода?
**Ответ.**  Аргументы метода хранятся в стеке (Java Virtual Machine stack). Если аргументом метода является объект, то ссылка на объект хранится в стеке, а значение - в куче (heap).
Даже при том, что поля класса хранятся в куче как часть самого класса, в том случае, когда они примитивы, при передачи их в качестве аргумента ссылка на них не создастся. Вместо этого в стек будет помещена копия значения данного поля класса (и уже все действия метода будет производится над ней.
**Источник.** https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.6
http://qaru.site/questions/283412/where-does-the-jvm-store-primitive-variables

 
12) В какой области памяти хранятся объекты?  
**Ответ.**  Объекты хранятся в куче (heap). Куча – это область памяти времени выполнения, содержащая массивы и экземпляры всех классов.  
Heap(Куча)-Пул памяти общего назначения (находится также в RAM), в котором размещаются все объекты Java. Преимущество кучи состоит в том, что компилятору не обязательно знать, как долго просуществуют находящиеся там объекты. Таким образом, работа с кучей дает значительное преимущество в гибкости.  
Когда вам нужно создать объект, вы пишете код с использованием new, и память выделяется из кучи во время выполнения программы. Конечно, за гибкость приходится расплачиваться: выделение памяти из кучи занимает больше времени, чем в стеке.
**Источник.** https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5.2  
https://proft.me/2014/06/7/kak-java-hranit-dannye-v-pamyati/

 
13) В какой области памяти хранятся ссылки на объекты?  
**Ответ.**  Ссылки на объекты хранятся в стеке (Java Virtual Machine stack), но если ссылка на объект является полем объекта, то данная ссылка вместе с объектом хранится в куче (heap) вместе с этим объектом.
**Источник.** https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5.3

 
14) В какой области памяти хранятся массивы?  
**Ответ.**  Массивы хранятся в куче (heap). Куча – это область памяти времени выполнения, содержащая массивы и экземпляры всех классов.  
**Источник.**https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5.3  

 
15) Дайте определение массива.  
**Ответ.**  Массив — это совокупность элементов: 
a.	одного и того же типа, 
b.	постоянная по размеру,
c.	расположенных в памяти непосредственно друг за другом.  
**Источник.**  http://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html  

 
16) Назовите 3 этапа создания массива. Какие действия выполняет JVM на каждом этапе?  
**Ответ.** a.Объявление (declaration)
На этом этапе определяется только переменная типа ссылка (reference) на массив, содержащая тип массива. Для этого записывается имя типа элементов массива, квадратными скобками указывается, что объявляется ссылка на массив, а не простая переменная	
b.Определение (instantiation)
На этом этапе указывается количество элементов массива, называется его размером, выделяется место для массива в оперативной памяти, переменной-ссылке присваивается оператором = адрес массива. На данном этапе для каждого массива автоматически определяется целая константа с именем length, равная длине массива. Все эти действия производятся оператором new за которым следует тип элементов массива.
c.Инициализация  (initialization)
На этом этапе элементы массива получают начальные значения.  
**Источник.** http://pr0java.blogspot.com/2015/05/1.html  


17) Приведите различные способы инициализации массива.  
**Ответ.** Инициализировать элементы массива значениями можно несколькими способами:
●	Присвоить 	каждому элементу массива конкретное 	значение (это можно сделать и в цикле, 	но до этого массив уже должен быть 	объявлен и создан). Например:  
```java
int [] ar = new int [2];
ar [0] = 1;
ar [1] = 2;	
```
●	Инициализировать 	массив при помощи перечисления значений 	его элементов в фигурных скобках (это 	можно сделать как на этапе объявления, 	так и на этапе создания, но синтаксис 	при этом разный).  
Например:
```java
int [] ar = { 1 , 2 };
int [] ar = new int [] { 1 , 2 };
```  
**Источник.** http://pr0java.blogspot.com/2015/05/1.html  

 
18) Дан массив  
```java
int[] values = {...};
//в фигурных скобках корректный список инициализации.
```
Есть ли различие в проходе по массиву циклами:
```java
for(int i=0; i < values.length; i++) {...}
for(int value : values) {...}
```
Если да, то в чем различие заключается?
Как называется каждый цикл?
**Ответ.**
a. цикл со счётчиком или цикл по записи. Цикл со счетчиком ``for`` предназначен для прохода, изменения и инициализации элементов массива.  
В ``for`` при проходе по массиву мы напрямую обращаемся к значению элемента массива и таким образом можем его изменить. Цикл ``for`` может перебирать элементов массива, перебирать элементы массива с начала, перебирать элементы массива с конца.
b. foreach или цикл по чтению. foreach проходит массив с помощью объекта итератор (foreach реализует интерфейс java.lang.Iterable). На каждой итерации цикла программа извлекает следующий элемент коллекции и сохраняет его в итерационной переменной (value в данном примере), а значит, что при изменении значения этой переменной, значение переменной в массиве не изменится.  
Цикл выполняется до тех пор, пока не переберутся все элементы коллекции. Исключается возможность выхода за пределы массива. С помощью foreach нельзя проинициализировать массив.
**Источник.** http://pr0java.blogspot.com.by/2015/05/1.html

 
19) Можно ли создать массив нулевой длины? Если да, то для каких целей он необходим?
Ответ: Да, массив нулевой длины объявляется следующим образом:
```java
new type[0] //где type - имя примитивного типа или
new Type[0] //где Type - имя ссылочного типа.
```
Такой массив не эквивалентен объекту ``null``.
Пустой массив принято использовать в тех местах программы, где заранее неизвестно, будут элементы или нет. Если элементы будут, то возвращается не пустой массив, если элементов нет - пустой массив. Примером может служить массив строк который передается в метод ``main()`` и содержит аргументы командной строки, а если их нет, то возвращается пустой массив..
Плюсы такого подхода:
a. Обработка такого массива не требует дополнительного кода.  
b. Можно возвращать один и тот же массив нулевой длины, поскольку любой массив нулевой длины неизменяем, а неизменяемые объекты доступны для совместного использования  
c. Чтобы избежать необходимости проверки (``if``) на ``null``.  
d. Для использования вместо ``null`` с целью избежать ``NullPointerException`` и там где  null нельзя использовать.  
e. Для более эффективного копирования двухмерного массива.  
**Источник.** Дж. Блох “Эффективное программирование”, статья 27.  

 
20) Что собой представляет двумерный массив? Многомерный массив?  
**Ответ.** Двумерный массив - это одномерный массив, элементами которого являются одномерные массивы.  
Многомерных массивов в Java не существует, но можно объявлять массив массивов.  
По сути многомерный  массив - это одномерный массив, элементами которого являются (n-1)-мерные массивы.Объявляется с использованием двух и более пар квадратных скобок. Строки в таком массиве могут варьироваться по длине.  
При распределении памяти под многомерный массив необходимо указать память только для первого (левого) измерения. Для каждого из остальных измерений память можно распределять отдельно. Например, следующий код резервирует память для первого измерения массива twoD при его объявлении.  
Распределение памяти для второго измерения массива осуществляется вручную.  
```java
int twoD[][] = new int[4][] ;
twoD[0] = new int[5];
twoD[l] = new int[5];
twoD[2] = new int[5];
twoD[3] = new int[5];
```
**Источник.** https://docs.oracle.com/javase/tutorial/java/nutsandbolts/arrays.html  

 
21) Перечислите ссылочные типы.  
**Ответ.** Классы, интерфейсы, перечисления, массивы, переменные типов  
**Источник.** https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.3  

 
22) Какая структура у java-файла (внутренности класса не указывать)?  
Какие из элементов структуры являются обязательными?  
**Ответ.** Общая форма файла, содержащего исходный код Java, может быть следующая:  
a.одиночный оператор ``package`` (не обязателен, но крайне желателен);  
b.любое количество операторов ``import`` (необязательны);  
c.одиночный открытый (``public``) класс (не обязателен);  
d.любое количество классов пакетного уровня доступа (необязательны и нежелательны; исключение в целях тестирования - один публичный класс и классы-раннеры пакетного уровня доступа);
e.комментарии (не обязательны, могут идти в самом начале файла перед объявлением пакета).  
Классы в файле могут отсутствовать. При этом в результате компиляции не будет создан ни один файл с расширением *.class.  
**Источник.** И.Н. Блинов, В. С. Романчик, Java. Методы программирования, стр. 120  

 
23) Для чего предназначены пакеты?  
**Ответ.** Пакет - это пространство имен, которое организует набор связанных классов и интерфейсов.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/concepts/package.html,  
Ильдар Хабибуллин «Самоучитель Java» стр. 98-99  

 
24) Как выглядит полное имя класса?  
**Ответ.** Каждый класс имеет как простое имя, данное ему в определении, так и полное имя, включающее имя пакета, в который он входит. Например, класс String является частью пакета java.lang, а его полное имя – java.lang.String.  
```
**Источник.** http://java-online.ru/java-package.xhtml  

 
25) Для чего предназначен оператор import?  
**Ответ.** В Java оператор импорта используется для отображения определенных классов или целых пакетов. Сразу после импорта на класс можно ссылаться напрямую, используя только его имя.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/package/usepkgs.html https://codescracker.com/java/java-importing-packages.htm  


26) Для чего предназначен статический импорт?  
**Ответ.** Если обычное объявление импорта импортирует классы из пакетов, позволяя использовать их без квалификации пакета, объявление статического импорта импортирует статические члены из классов, позволяя использовать их без квалификации класса.  

Пример:
```java
import static java.lang.Math.* 
\\позволяет записать строку:
System.out.println(2 * Math.PI * 3)
\\в виде:
System.out.println(2 * PI * 3);
```
**Источник.** https://docs.oracle.com/javase/1.5.0/docs/guide/language/static-import.html  

 
27) Сколько внешних публичных классов можно объявить в одном java-файле?  
**Ответ.** В одном java-файле может быть не более одного публичного класса (0 или 1) и любое количество классов пакетного уровня доступа. Имя публичного класса должно совпадать с именем файла.  
**Источник.** Ильдар Хабибуллин «Самоучитель Java» стр. 106  

 
28) Может ли синтаксически правильный java-файл иметь имя 1.java? Если да, то какие ограничения?  
**Ответ.** Может, если в файле 1.java содержатся только классы пакетного уровня доступа.  
**Источник.** Ильдар Хабибуллин «Самоучитель Java» стр. 106  

 
29) Допустим, в одном java-файле объявлены два синтаксически правильных внешних класса. Какие могут быть результаты компиляции данного файла?  
**Ответ.** Возможно 2 варианта результата компиляции:  
1. Ошибка компиляции.  
1.1. В случае, если оба класса объявлены с модификатором доступа ``public``,  
1.2. либо имя ``public`` класса не совпадает (с учетом регистра) с именем файла, в котором он объявлен;  
2. Успешная компиляция.  
2.1. Если имя ``public`` класса совпадает (с учетом регистра) с именем файла, в котором он объявлен, а второй класс имеет пакетный уровень доступа (``package private``),  
2.2. либо в файле объявлены 2 класса с пакетным уровнем доступа.  
В результате компиляции будут созданы 2 class-файла, имена которых будут совпадать с именами классов, объявленных в исходном файле.  
**Источник.** http://docs.oracle.com/javase/7/docs/technotes/tools/solaris/javac.html  

 
30) Как записывается заголовок метода main() раннер-класса (т.е. класса, который может стартовать из-под JVM)?  
Это единственный способ?  
**Ответ.**
```java
public static void main(String[] args)
public static void main(String ... args)
```
Метод ``main()`` записывается как обычный метод, может содержать любые описания и действия, но он обязательно должен быть открытым (``public``), статическим (``static``), не иметь возвращаемого значения (``void``). Его аргументом обязательно должен быть массив строк (``String[]``). По традиции этот массив называют args , хотя имя может быть любым.  
Эти особенности возникают из-за того, что метод ``main()`` вызывается автоматически исполняющей системой Java в самом начале выполнения приложения. При вызове интерпретатора java указывается класс, где записан метод ``main()`` , с которого надо начать выполнение.  
Встречается вариативность ``public static`` и ``static public``, но второй вариант не соответствует Code Conventions.
**Источник.** https://docs.oracle.com/javase/tutorial/getStarted/application/

 
31) Может ли один java-файл содержать два и более раннер-класса?   
**Ответ.** Java-файл может содержать два и более раннер-класса с разными именами. Они скомпилируются в отдельные class-файлы и через любой из них можно исполнить программу. И только один такой раннер-класс может быть ``public``, а остальные ``package private`` раннер-класы.  
Пример:
```java
public class Runner {
  	public static void main(String[] args) {
        	System.out.println("Runner");
  	}
}
 
class Runner2 {
  	public static void main(String[] args) {
        	System.out.println("Runner2");
  	}
}
```
  
32) Можно ли определить метод ``main()`` с другими модификаторами?  
**Ответ.** Да, метод ``main()`` можно объявить по правилам любого другого метода. Но только в двух случаях, приведенных выше, он будет являться точкой входа в программу.
**Источник.** https://docs.oracle.com/javase/tutorial/getStarted/application/  

 
33) Может ли в классе быть два и более метода ``main()``?  
Если да, то приведите пример.  
**Ответ.** Это серия перегруженных методов. Вы можете перегрузить метод ``main()``, но только ``public static void main(String[] args)`` будет использоваться, когда ваш класс запускается JVM.  
```java
public class MultipleMain{
public static void main(String args[]){
main(1);
main('c');
main("MyString");
}
public static void main(int i){
System.out.println("Inside Overloaded main()")
}
public static void main(char i){
System.out.println("Inside Overloaded main()");
}
public static void main(String str){
System.out.println("Inside Overloaded main()");
    }
}
```
**Источник.** http://qaru.site/questions/469566/multiple-main-methods-in-java  


34) Может ли в классе быть два метода ``main()``, один из которых раннер, а второй метод ``main()`` отличается от первого только отсутствием модификатора ``static``?  
Если да, то приведите пример вызова второго метода.  
**Ответ.** Модификатор ``static`` не входит в сигнатуру метода, поэтому с точки зрения компилятора класс будет содержать два одинаковых метода и будет ошибка компиляции.  
```java
Duplicate method main(String[]) in type run
public class Runner {
   	public static void main(String[] args){
    		System.out.println("Hello, World!");
}
 
public void main(String[] args){
  		System.out.println("args ");
}
}
```
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/methods.html  


35) В корне проекта имеется файл HelloWorld.java, пути к необходимым ресурсам открыты.  
Создайте bat-файл для запуска приложения на выполнение.  
**Ответ.** bat-файл имеет следующие строки:  

javac HelloWorld.java  
java HelloWorld  

**Источник.** https://docs.oracle.com/javase/tutorial/getStarted/cupojava/win32.html  

 
36) В корне проекта имеется  
1. папка src для исходных java-файлов, а в ней – файл HelloArgs.java, который выводит приветствие для каждого аргумента командной строки;  
2. папка bin для class-файлов.  
Пути к компилятору и JVM открыты, переменная CLASSPATH не установлена.  
Создайте bat-файл для запуска приложения с двумя аргументами командной строки clever и 25007 на выполнение.  
**Ответ.**
javac -sourcepath src -d bin src/HelloArgs.java  
java -classpath bin HelloArgs clever 25007  
**Источник.** http://skipy.ru/technics/likbez.html  

 
37) Имеется корректный файл helloWorld.jar.  
Создайте bat-файл для запуска приложения на выполнение.  
**Ответ.** java -jar helloWorld.jar
Эту команду необязательно выполнять из той директории, где находится корень проекта. Можно указать полный путь, например, так: java -jar d:\projects\HelloWorld\helloWorld.jar  
**Источник.**   http://skipy.ru/technics/likbez.html  

 
38) Какие есть виды комментариев?  
**Ответ.**  
a. «Однострочные»  - // от начала символов и до конца строки.  
b. «Блочные (многострочные)» -  /* все что находится между данными символами комментарий */.  
c. «Документирующий» (javadoc) - Этот вид комментариев служит для создания НТМL-файла документации на программу, документирующий комментарий начинается с символов / ** и оканчивается символами */.  
Источник: https://docs.oracle.com/javase/tutorial/getStarted/application/index.html,  
И.Н.Блинов Java Методы программирования – стр. 35
