1) Какие уровни доступа есть у класса на верхнем уровне, т.е. у внешнего класса?  
**Ответ.** По умолчанию классы верхнего уровня доступны в том пакете, в котором они определены. Впрочем, если класс верхнего уровня объявлен как public, то он доступен везде (или везде, где доступен сам пакет).  
**Источник.** http://pr0java.blogspot.com/2015/07/1.html  


2) Что является членами класса?  
**Ответ.** Переменные и методы.  
**Источник.** И.Н.Блинов Java Методы программирования – с. 55  

 
3) Что еще можно определить в классе кроме членов?  
**Ответ.** Конструкторы, статические инициализаторы и инициализаторы экземпляров.  
**Источник.** https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.2  

 
4) Какие уровни доступа есть у членов класса?  
**Ответ.** Поля класса, как и методы, объявляются также со спецификаторами доступа public, private, protected или по умолчанию без спецификатора.  
**Источник.** И.Н.Блинов Java Методы программирования – с. 55  


5) Какие модификаторы необходимы для определения константы:  
1. класса,  
2. экземпляра класса?  
**Ответ.** Константа класса опрелделяется при помощи спецификаторов static final.  
Константа экземпляра определяется при помощи спецификатора final.  
**Источник.** И.Н.Блинов, В.С.Романчук Java 2 проктическое руководство – с. 46


Обратный вопрос. Допустим, у некоторого класса есть 4 следующих поля:  
```java
class SomeClass {
	private int a;
	private final int b;
private static int c;
private static final int D;
...
}
```
6) Как можно назвать данные поля в зависимости от комбинации модификаторов static и final?  
**Ответ.** 
```java
class SomeClass {
	private int a;			//поле класса, которое является переменной экземпляра (у каждого экземпляоа своя копия);
	private final int b;	//поле класса, которое является константой (инициализируется лишь однажды, и не изменяется. должна инициализироваться при 						объявлении или в теле конструктора или блоке инициализации, иначе произойдет ошибка компиляции.);
	private static int c;	//поле класса, которое является статическим (переменная класса, при изменении значения одним обьектом, значение изменится и 							для всех остальных объектов)
	private static final int D;	//поле класса, статическая константа;
...
}
```  
 
 
7) Может ли класс не иметь ни одного конструктора? Почему?  
**Ответ.** Не может. Дело в том, что если конструктор класса не определен явно, то в Java для класса создается конструктор по умолчанию. Конструктор по умолчанию инициализирует все переменные экземпляра устанавливаемыми по умолчанию значениями. Но как только в классе будет определен собственный конструктор, конструктор по умолчанию больше не используется.  
**Источник.** https://www.examclouds.com/ru/java/java-core-russian/konstruktori 


8) Перечислите отличия конструктора от метода.  
**Ответ.** Определение конструктора и метода  
Конструктор похож на метод экземпляра в Java, за исключением возвращаемого типа. Конструкторы - это специальные типы методов в Java, используемые для инициализации объектов своего класса. Он имеет то же имя, что и класс, в котором он находится. Методы, с другой стороны, относятся к набору кода, который может быть вызван в любой точке программы через имя метода для выполнения некоторой задачи и возврата результата..  
Цель конструктора и метод  
Целью конструктора является создание экземпляра класса. Это достигается созданием объекта в памяти и возвращением ссылки на него. Это специальный тип метода, используемый для инициализации объекта сразу после его создания. С другой стороны, цель метода состоит в том, чтобы сгруппировать блок операторов для выполнения операций над уже существующими объектами..  
Имя  
Конструкторы обозначаются тем же именем, что и имя класса, и они не имеют возвращаемого типа. Ключевое слово ``new`` используется для создания объекта класса и вызова конструктора для инициализации созданного объекта. Методы, напротив, именуются не так, как имя класса, и они должны быть объявлены до того, как он что-то возвратит, хотя методы могут быть недействительными.  
Наследование конструктора и метода  
Конструкторы не наследуются подклассами, так как они не являются членами класса. Однако конструктор суперкласса (родительского класса) может быть вызван из подкласса. Методы, с другой стороны, наследуются подклассом, чтобы обеспечить возможность повторного использования кода.  
Функция конструктора и метода  
Конструкторы не могут быть вызваны напрямую. Фактически, конструкторы вызываются неявно, когда для создания объектов используется ключевое слово new. Методы, с другой стороны, являются статическими по своей природе, что означает, что их можно вызывать напрямую, не создавая экземпляр этого класса. Фактически, методы начинают работать в существующем потоке.  
**Источник.** https://ru.sawakinome.com/articles/technology/difference-between-constructor-and-method-3.html  
 
 
9) Как и в каком месте можно вызвать из одного конструктора другой конструктор этого же класса?  
**Ответ.** Вы можете вызвать один конструктор из другого в том же классе, или в надклассе, со следующими ограничениями:  
a) Вызываемый конструктор должен быть в первой строке кода в вызывающем конструкторе.  
b) Вложенный конструктор не может иметь никакой явной или неявной ссылки на ``this``. Таким образом, вы не можете попасть во внутренний класс.  
 **Источник.** https://javarush.ru/groups/posts/1187-raznica-mezhdu-kljuchevihmi-slovami-this-i-super-v-java  
 
 
10) Как и в каком месте можно вызвать конструктор суперкласса?  
**Ответ.** Если класс наследует свойства другого класса, подкласс автоматически получает конструктор по умолчанию суперкласса. Но если вы хотите вызвать параметризованный конструктор суперкласса, вам нужно использовать ключевое слово super. ``super(values)``  
**Источник.** https://hr-vector.com/java/nasledovanie  
 
 
11) Что делает компилятор, если в конструкторе нет вызова другого конструктора или конструктора суперкласса?  
**Ответ.** Каждый конструктор при отсутствии явных вызовов других конструкторов неявно вызывает с помощью ``super()`` конструктор без аргументов родительского класса, при этом у вас всегда остается возможность явно вызвать любой другой конструктор с помощью либо ``this()``, либо super().  
**Источник.** https://javarush.ru/groups/posts/1187-raznica-mezhdu-kljuchevihmi-slovami-this-i-super-v-java  


12) Можно ли одновременно использовать конструкции this() и super() в одном и том же конструкторе? Обоснуйте **Ответ.**  
**Ответ.** Внутри конструктора this и super должны стоять выше всех других выражений, в самом начале, иначе компилятор выдаст сообщение об ошибке. Из чего следует, что в одном конструкторе не может быть одновременно и this(), и super().  
**Источник.** https://javarush.ru/groups/posts/1187-raznica-mezhdu-kljuchevihmi-slovami-this-i-super-v-java  


13) Может ли быть приватный уровень доступа у конструктора? Если да, то для каких целей он необходим?  
**Ответ.** Частные конструкторы предотвращают явное создание экземпляра класса вызывающими объектами. Есть несколько распространенных случаев, когда может быть полезен частный конструктор:  
a) классы, содержащие только статические служебные методы  
b) классы, содержащие только константы  
c) типобезопасные перечисления  
d) синглтоны  
Эти примеры делятся на две категории.  
Строительство объекта категорически запрещено. Никакие объекты не могут быть созданы ни вызывающим, ни собственным классом. Это подходит только для классов, которые предлагают вызывающему только статические члены. В этих случаях отсутствие конструктора доступа говорит вызывающему: «Для этого класса нет вариантов использования, когда вам нужно построить объект. Вы можете использовать только статические элементы. Я не позволяю вам даже пытаться построить объект. этого класса ".  
**Источник.** http://www.javapractices.com/topic/TopicAction.do?Id=40  


14) Какие модификаторы может иметь конструктор?  
**Ответ.** В конструкторе допускается применение модификаторов доступа, можно задать один из модификаторов: public, protected, private или без модификатора.  
**Источник.** https://javarush.ru/groups/posts/1391-konstruktorih-klassov-java-jdk-15  


15) Конструктор принадлежит классу или экземпляру класса?  
**Ответ.** Конструктор принадлежит классу, в котором он объявлен.  
**Источник.** https://metanit.com/java/tutorial/3.1.php  


16) Можно ли наследовать конструктор? Если да, то приведите примеры.  
**Ответ.** в Java конструкторы не являются членами, поэтому они не наследуются подклассом, но конструктор суперкласса может быть вызван из подкласса.  
**Источник.** https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.2  

17) Какой тип возвращаемого конструктором значения?  
**Ответ.** Конструкторы же не имеют возвращаемого типа, они не могут возвращать даже тип void.  
**Источник.** http://www.javable.com/javaworld/10_00/01/  


18) Дан класс.
```java
class Null {
	//фрагмент 1
	Null Null() {
		return null;
	}
	//фрагмент 2
	Null() {
		return null;
	}
}
```
В каком фрагменте ошибка компиляции?  
Удалите этот фрагмент полностью.  
Прокомментируйте оставшийся фрагмент и продемонстрируйте функционал класса.  
**Ответ.** Ошибка во втором фрагменте. Конструктор не может вернуть null.  
```java
 class Null {
    public static void main(String[] args) {
        Null test = new Null(); // создаем экземпляр класса Null, с помощью конструктора по умолчанию
        test.Null();// вызывается метод Null на объект test и возвращается значение null
        System.out.println(test); // output: null
    }
    //фрагмент 1
    Null Null() {
        return null;
    }
}
```

19) Если метод имеет то же имя, как и класс, то каким образом транслятор определяет где метод, а где конструктор (см. пример выше)?
**Ответ.** Конструктор в отличие от метода ничего не возвращает.  
**Источник.** https://ru.sawakinome.com/articles/technology/difference-between-constructor-and-method-3.html  


20) Дан класс.
```java
class Name {
	String name;
	Name() {
		this(makeRandomName());
	}
	Name(String name) {
		super();
		this.name = name;
	}
	String makeRandomName() {
		int k = (int) (Math.random() * 3);
		String name = new String[] {"Alpha", "Beta", "Gamma"}[k];
		return name;
	}
	public String toString() {
		return name;
	}
	public static void main(String[] args) {
		System.out.println(new Name());
	}
}
```
Объясните причину ошибки компиляции. 
Предложите минимум 2 способа исправления ошибки, использовать метод makeRandomName() обязательно.  
**Ответ.** Проблема заключается в том что метод ``makeRandomName()`` является метдом экземпляра класса и не будет доступен до тех пор, пока ``super`` не будет вызван из конструктора, что приведет к инициализации класса. Вы пытаетесь вызвать ``makeRandomName()`` до того, как вызов super инициализирует класс, что приведет к ошибке компиляции.  
```java
//Вариант 1:
class Name {
    String name;
    Name() {
        this(makeRandomName());
    }
    Name(String name) {
        super();
        this.name = name;
    }
    static String makeRandomName() {
        int k = (int) (Math.random() * 3);
        String name = new String[] {"Alpha", "Beta", "Gamma"}[k];
        return name;
    }
    public String toString() {
        return name;
    }
    public static void main(String[] args) {
        System.out.println(new Name());
    }
}
//Вариант 2:
class Name {
    String name;
    Name() {
        this.name = makeRandomName();
    }
    Name(String name) {
        super();
        this.name = name;
    }
    String makeRandomName() {
        int k = (int) (Math.random() * 3);
        String name = new String[] {"Alpha", "Beta", "Gamma"}[k];
        return name;
    }
    public String toString() {
        return name;
    }
    public static void main(String[] args) {
        System.out.println(new Name());
    }
}
```  


21) Дан класс.  
```java
class Int {
	int i;
	void inc(Int param) {
		//param = new Int();
		param.i++;
	}
	public static void main(String[] args) {
		Int obj = new Int();
		obj.inc(obj);
		System.out.println(obj.i);
	}
}
```
Изменится ли результат, если убрать комментарий? Объясните, почему?  
**Ответ.** Результат будет разный. Если не убирать комментарий, то вернется 1 т.к. созданый объект вызывает метод ``inc()`` который после инициализации ``i`` увеличит ее на 1 и вернет ее на вызываемом объекте. Если же комментарий убрать то вернется 0, т.к. в методе создасться новый экземпляр на котором в последующем ``i`` будет увеличена, но на объекте который вызывал метод изначально ``i`` так и осталась инициализированой 0.  


22) Что входит в сигнатуру метода?  
**Ответ.** Имя метода, число и типы параметров образуют сигнатуру (signature) метода.  
**Источник.** Ильдар Хабибуллин «Самоучитель Java» с. 87  


23) Что значит ключевое слово native?  
**Ответ.** Приложение на языке Java может вызывать методы, написанные на языке С++(либо на другом языке). Такие методы объявляются с ключевым словом native, которое сообщает компилятору, что метод реализован в другом месте. Например: ``public native int loadCripto(int num)``. Методы, помеченные ``native``, можно переопределять обычными методами в подклассах.  
**Источник.** И.Н.Блинов Java Методы программирования – с. 64  


24) Перечислите, какой код в классе можно выполнить до создания объекта.  
**Ответ.** При создании объекта класса логические блоки вызываются последовательно, в порядке размещения, вместе с инициализацией полей как простая последовательность операторов, и только после выполнения последнего блока будет вызван конструктор класса.  
**Источник.** И.Н.Блинов, В.С.Романчук Java 2 проктическое руководство – с. 50  

 
25) В чем различие между объектом и экземпляром класса?  
**Ответ.** Объект: объекты реального мира имеют две основные характеристики: состояние и поведение. У человека есть состояние (имя, возраст) и поведение (бег, сон). Автомобиль имеет состояние (текущая скорость, текущая передача) и поведение (включение тормоза, переключение передач). Программные объекты концептуально похожи на объекты реального мира: они также состоят из состояния и связанного поведения. Объект сохраняет свое состояние в полях и раскрывает свое поведение с помощью методов.  
Экземпляр - это уникальная копия класса, представляющая объект. Когда создается новый экземпляр класса, JVM выделяет пространство памяти для этого экземпляра класса.  
**Источник.** https://alfredjava.wordpress.com/2008/07/08/class-vs-object-vs-instance/  


26) Назовите три этапа создания экземпляра класса.  
**Ответ.**  
a) Декларация. Декларирование переменной типа класса с уникальным именем.  
b) Инстанциация. Создание нового объекта с использованием ключевого слова ``new``.  
c) Инициализация. Вызов конструкторов, который идёт после ключевого слова ``new``.  
**Источник.** https://proselyte.net/tutorials/java-core/classes-and-objects/  
 
 
27) Охарактеризуйте отношение композиции между классами? Как оно реализуется?  
**Ответ.** Композиция является одним из методов проектирования, который реализовывает отношение типа has-a в классах. Мы можем использовать наследование в Java или композицию для повторного использования кода.  
Композиция в Java достигается за счет использования переменных экземпляра, который ссылается на другие объекты.  
Небольшой пример в теории: Person has a (имеет) Job.
```java 
public class Job {
    private String role;
    private long salary;
    private int id;
         
    public String getRole() {
        return role;
    }
    public void setRole(String role) {
        this.role = role;
    }
    public long getSalary() {
        return salary;
    }
    public void setSalary(long salary) {
        this.salary = salary;
    }
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    } 
}
 
public class Person {
 
    //используем отношение has-a
    private Job job;
    
    public Person(){
        this.job=new Job();
        job.setSalary(1000L);
    }
    public long getSalary() {
        return job.getSalary();
    } 
}

public class TestPerson {
 
    public static void main(String[] args) {
        Person person = new Person();
        long salary = person.getSalary();
    }
 
}
```
Обратите внимание, что тестовая программа TestPerson не зависит от каких-либо изменений в объекте Job. Если вам нужно реализовать взаимодействие двух классов и вы хотите повторно использовать код, то лучшим выходом будет использование композиции вместо наследования.
Преимущества использования композиции в том, что мы можем управлять видимостью другого объекта для клиентских классов и повторно использовать только то, что нам нужно. Кроме того, если есть какие-либо изменения в другой реализации класса, например, если  метод ``getSalary()`` начнет возвращать строку, то мы должны изменить класс Person, а не классы клиента.
Композиция в Java позволяет создавать back-end класс, когда это необходимо. Например, мы можем изменить ``getSalary()`` метод класса Person для инициализации объекта Job.  
**Источник.** https://javadevblog.com/chto-takoe-kompozitsiya-primer-kompozitsii-v-java.html  

 
28) Для чего предназначен метод toString()? В каких случаях он вызывается?  
**Ответ.** Возвращает строковое представление объекта. Каждый раз, когда мы пытаемся вывести ссылку на ``Object``, вызывается метод toString(). 
Если мы не определили в классе метод ``toString()``, то будет вызван метод ``toString()`` класса ``Object``.  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html  


29) Как реализован метод toString() в классе Object?  
**Ответ.** 
```java
public String toString() {
        return getClass().getName() + "@" + Integer.toHexString(hashCode());
    }
```  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html  


30) Для чего предназначен метод equals()? В каких случаях он вызывается?  
**Ответ.** Метод equals реализует отношение эквивалентности для ненулевых ссылок на объекты. Вызывается при необходимости сравнения содержимого объектов.  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html  


31) Как реализован метод equals() в классе Object?  
```java
**Ответ.** public boolean equals(Object obj) {
        return (this == obj);
    }
```  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html  


32) В чем различие между методом equals() и операции ==? В каких случаях применение метода equals() и операции == эквивалентно?
**Ответ.** В Java сравнение объектов производится с помощью метода equals() класса Object. Этот метод сравнивает содержимое объектов и выводит значение типа boolean. Значение true - если содержимое эквивалентно, и false — если нет. Операция == не рекомендуется для сравнения объектов в Java. Дело в том, что при сравнении объектов, операция == вернет true лишь в одном случае — когда ссылки указывают на один и тот же объект. В данном случае не учитывается содержимое переменных класса. При создании пользовательского класса, принято переопределять метод equals() таким образом, что бы учитывались переменные объекта. Применение метода equals() и операции == эквивалентно в случае если метод equals() не переопределен.  
**Источник.** https://www.examclouds.com/ru/java/java-core-russian/method-equals  


33) Что такое garbage collection?
**Ответ.** Сборщик м усора (garbage collection) автоматически управляет запросами на выделение динамической памяти приложения.
Сборщик мусора выполняет автоматическое управление динамической памятью с помощью следующих операций:  
a) Выделяет и возвращает память операционной системе.  
b) Выдает эту память приложению, когда оно запрашивает ее.  
c) Определяет, какие части этой памяти все еще используются приложением.  
d) Освобождает неиспользуемую память для повторного использования приложением.  
**Источник.** https://docs.oracle.com/javase/9/gctuning/introduction-garbage-collection-tuning.htm#JSGCT-GUID-8A443184-7E07-4B71-9777-4F12947C8184  


34) Перечислите случаи, когда JVM отдает управление на garbage collector.  
**Ответ.**  
a) Если переменная ссылочного типа, которая ссылается на объект, установлена в положение "0", объект подлежит утилизации, в том случае, если на него нет других ссылок.  
b) Если переменная ссылочного типа, которая ссылается на объект, создана для ссылки на другой объект, объект подлежит утилизации, в том случае, если на него нет других ссылок.  
c)Объекты, созданные локально в методе, подлежат утилизации, когда метод завершает работу, если только они не экспортируются из этого метода (т.е, возвращаются или генерируются как исключение).  
d) Объекты, которые ссылаются друг на друга, могут подлежать утилизации, если ни один из них не доступен живому потоку.  
**Источник.** https://javarush.ru/groups/posts/917-sborka-musora  


35) Как сделать так, чтобы JVM сразу перешла в режим сборки мусора?  
**Ответ.** Для запроса запуска сборщика мусора используют один из методов: 
``System.gc()``;  
``Runtime.getRuntime().gc()``  
**Источник.** https://javarush.ru/groups/posts/917-sborka-musora  


36) Гарантирует ли garbage collector, что приложение в любом случае не будет иметь проблемы с недостатком памяти? Обоснуйте **Ответ.**  
**Ответ.** Нет. Сборщик мусора помогает вам автоматически освобождать неиспользуемую память. Это работает так: если ссылка на объект не может быть достигнута, память для этого объекта может быть собрана в мусор.  

```java
//Например:
public void test() {
     Object o = new Object();
     // the memory used by  o may be garbage collected after this line
}
//Но если вы никогда не освободите ссылки на объекты, сборщик мусора никогда ничего не соберет, и OutOfMemoryError будет выброшен.

List list = ....
public void test() {
     o = new Object();
     list.add( o ); 
     // the memory used by  o WON'T be garbage collected after this line
     // because its reference is used in the list.
}
//Если вы используете это несколько раз:

 while( true ) {
     test();
 }
//Список будет расти бесконечно, пока у вас не закончится память
```  


37) Для чего предназначен метод finalize()? Какой недостаток у метода?  
**Ответ.** Общий контракт ``finalize()`` заключается в том, что он вызывается, если и когда виртуальная машина Java TM определила, что больше нет никаких средств, с помощью которых к этому объекту можно получить доступ для любого потока, который еще не умер, кроме как в результате предпринятого действия. путем завершения некоторого другого объекта или класса, который готов к завершению. Метод ``finalize()`` может предпринимать любые действия, в том числе делать этот объект снова доступным для других потоков; однако обычная цель ``finalize()`` - выполнить действия по очистке до того, как объект будет безвозвратно удален.   Спецификация языка Java не только не даёт поручительства, что методы ``finalize()`` будут вызваны быстро, она не даёт гарантии, что они вообще будут вызваны. Вполне возможно и даже очень вероятно, что программа завершится, так и не вызвав для некоторых объектов, ставших недоступными, метода ``finalize()``. Как следствие, вы никогда не должны полагаться на метод ``finalize()`` для обновления критического хранимого (persistent) состояния. Например, ставить освобождение хранимой блокировки разделяемого ресурса, такого как база данных, в зависимость от метода ``finalize()`` — верный способ привести всю вашу распределённую систему к сокрушительному краху. Если в ходе утилизации возникает необработанное исключение, оно игнорируется, а вызов метода ``finalize()`` прекращается [JLS, 12.6]. Необработанное исключение может оставить объект в испорченном состоянии. И если другой поток попытается воспользоваться таким испорченным объектом, результат может быть непредсказуем. Обычно необработанное исключение завершает поток и выдаёт распечатку стека, однако в методе ``finalize()`` этого не происходит, он даже не даёт предупреждений. Так же очень сильно замедляется создание и уничтожение объектов.  
**Источник.** Джошуа Блох «Effective Java: Programming Language Guide» с. 54-55  
https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html  


38) Для чего предназначены оболочечные классы? Как они называются на инглише?  
**Ответ.** Классы-оболочки(wrapper) примитивных типов - предназначены для действий, типичных при работе с классами, — создания объектов, преобразования типов объектов, получения численных значений объектов в разных формах и передачи объектов в методы по ссылке.  
**Источник.** Ильдар Хабибуллин «Самоучитель Java» с.133  


39) В чем преимущество примитивных типов перед соответствующими оболочечными классами?  
**Ответ.** Арифметические действия удобнее и быстрее производить с примитивными типами, а не с объектами классов, которые требуют много ресурсов от компьютера.  **Источник.** Ильдар Хабибуллин «Самоучитель Java» с.133  


40) Что такое autoboxing и unboxing?  
**Ответ.** Autoboxing - это автоматическое преобразование, которое компилятор Java выполняет между примитивными типами и соответствующими им классами-оболочками объектов. Например, преобразование int в Integer, double в Double и т.д. Если преобразование идет другим путем, это называется распаковкой.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html  


41) Дан код:
```java
Integer a = 3, b =7;
Long c = a + b;
```
Перечислите все операции, где задействованы autoboxing и unboxing.
**Ответ.** Операции где задействован autoboxing: ``Integer a = 3, b = 7``; ``Long c = a + b//при присвоении результата вычисления``.
Операция где задействован unboxing: ``a + b``;  


42) Дан корректный раннер-класс. Будет ли ошибка компиляции, если удалить модификатор static из сигнатуры метода main()? Обоснуйте **Ответ.**
Что произойдет, если отправить на выполнение измененный класс?  
**Ответ.** Ошибки не произойдет, метод ``main()`` можно объявить по правилам любого другого метода. Но только в двух случаях,он будет являться точкой входа в программу.  
```java
public static void main(String[] args)
public static void main(String ... args)
```
При запуске измененного класса, программа не запуститься, т.к. точка входа не определена.  
**Источник.** https://docs.oracle.com/javase/tutorial/getStarted/application/  


43) Дан класс.
```java
class Runner {
	public static void main(String[] args) {
        	System.out.println("Hello, world!");
	}
}
```
Запрещается изменять синий код, т.е. метод main().
Добавить код в класс Runner, так чтобы в результате запуска этого класса из под JVM в консоли был следующий результат:
I am java.
Hello, world!  
**Ответ.** 
```java
class Runner {
    static{
        System.out.println("I am Java");
    };
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
```

